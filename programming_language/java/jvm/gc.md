# Java GC（Garbage Collection）

## GC需要解决的三件事
* 哪些内存需要回收？
* 什么时候回收？
* 如何回收？

## 关注的内存区域
由于程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而灭，栈帧随方法进入和退出而入栈和出栈，这部分内存的分配和回收时机都是确定的，不属于GC关注的内存区域。

而**Java堆和元空间**则具有不确定性，比如同一个接口的实现类所需要的内存可能是不一样的，程序的不同分支所需的内存也可能会不一样，只有在运行期，程序才能知道会创建哪些对象，会创建多少个对象，这部分内存的分配和回收都是动态的，因此是GC关注的内存区域。

## 对象已死？

1. 引用计数法  
在对象中增加一个引用计数器，当有引用指向它时+1，当指向它的引用失效时-1.当其引用树为0时，则成为垃圾。但有一些例外情况需要额外处理，比如：循环引用。

2. 可达性分析法  
通过一序列称为“GC Roots”的根对象为起点，根据引用关系向下遍历，搜索过程走过的路径称为“引用链”，当遍历结束时，不再引用链上的对象即为垃圾对象。

固定可作为**GC Roots**的对象包括以下几种：
* 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如线程中被调用的方法栈帧中的参数、局部变量、临时变量等（运行上下文）
* 本地方法栈中JNI引用的对象（运行上下文）
* 所有被同步锁（synchronized）持有的对象（运行上下文）
* 方法区（元空间）中类静态属性引用的对象，譬如Java类的引用类型静态变量（全局）
* 方法区（元空间）中常量引用的对象，譬如字符串常量池中的引用（全局）
* JVM内部的引用，譬如基本数据类型对应的Class对象、一些常驻的异常对象（NullPointException、OutOfMemoryError）等、类加载器（全局）
* 反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等（全局）

除这些固定的GC Roots外，根据用户选择的垃圾收集器以及当前收集的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整的GC Roots集合。比如分代收集和局部回收（Partail GC），当只回收Java堆某一局部内存时（比如新生代），需考虑可能存在其他区域对象对该区域的引用（比如老年代指向新生代的引用），因此需将其关联的内存区域对象也加入到GC Roots中，才能保证可达性分析的正确性。


## 四种引用
* 强引用（Strongly Reference）
* 软引用（Soft Reference）：在内存足够时不回收，但如果内存不足，在溢出之前会回收只被软引用引用的对象，还不足才报溢出异常。  
* 弱引用（Weak Reference）：只
* 虚引用（Phanthon Reference）  
