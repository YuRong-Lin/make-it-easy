# Java GC（Garbage Collection）

## GC需要解决的三件事
* 哪些内存需要回收？
* 什么时候回收？
* 如何回收？

## 关注的内存区域
由于程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而灭，栈帧随方法进入和退出而入栈和出栈，这部分内存的分配和回收时机都是确定的，不属于GC关注的内存区域。

而**Java堆和元空间**则具有不确定性，比如同一个接口的实现类所需要的内存可能是不一样的，程序的不同分支所需的内存也可能会不一样，只有在运行期，程序才能知道会创建哪些对象，会创建多少个对象，这部分内存的分配和回收都是动态的，因此是GC关注的内存区域。

## 对象已死？

1. 引用计数法  
在对象中增加一个引用计数器，当有引用指向它时+1，当指向它的引用失效时-1。当其引用计数为0时，则成为垃圾。但采用该算法有一些例外情况需额外处理，如循环引用等。

2. 可达性分析法  
通过一序列称为“GC Roots”的根对象为起点，根据引用关系向下遍历，搜索过程走过的路径称为“引用链”，当遍历结束时，不在引用链上的对象即为垃圾对象。

固定可作为**GC Roots**的对象包括以下几种：
* 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如线程中被调用的方法栈帧中的参数、局部变量、临时变量等（运行上下文）
* 本地方法栈中JNI引用的对象（运行上下文）
* 所有被同步锁（synchronized）持有的对象（运行上下文）
* 方法区（元空间）中类静态属性引用的对象，譬如Java类的引用类型静态变量（全局）
* 方法区（元空间）中常量引用的对象，譬如字符串常量池中的引用（全局）
* JVM内部的引用，譬如基本数据类型对应的Class对象、一些常驻的异常对象（NullPointException、OutOfMemoryError）等、类加载器（全局）
* 反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等（全局）

除这些固定的GC Roots外，根据用户选择的垃圾收集器以及当前收集的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整的GC Roots集合。比如分代收集和局部回收（Partail GC），当只回收Java堆某一局部内存时（比如新生代），需考虑可能存在其他区域对象对该区域的引用（比如老年代指向新生代的引用），因此需将其关联的内存区域对象也加入到GC Roots中，才能保证可达性分析的正确性。


## 四种引用
* 强引用（Strongly Reference）：常见的引用赋值，存在强引用的对象永远不会被回收。
* 软引用（SoftReference）：只有软引用的对象在内存足够时不被回收，但如果内存不足，则在溢出之前会被回收，若还不足才报溢出异常。  
* 弱引用（WeakReference）：只有弱引用的对象在下一轮垃圾收集时被回收。
* 虚引用（PhanthonReference）：也被称为“幽灵引用”或“幻象引用”，不影响对象的生存时间，也不能通过它获得对象实例。设置虚引用的唯一目的是在对象被回收时收到一个通知。


## 应该忘掉的对象逃生之术- finalize()方法
一个对象被宣告死亡，至少要经历两次标记过程。当对象不在GC Roots引用链上时被第一次标记，然后会进行一次筛选，筛选的条件是该对象是否需要执行finalize方法。如果对象没有覆盖finalize方法或者finalize方法已被调用过，则认为该对象不需要执行finalize方法。

如果判定要执行finalize方法的话，则该对象会被放入到一个F-Queue队列中，由JVM创建的一个低调度优先级的Finalizer线程来执行该队列中的对象的finalize方法（只触发不保证执行结束）。这是对象逃脱死亡命运的最后一次机会。稍后收集器会对F-Queue队列中的对象进行第二次小规模标记，成功逃脱的对象则被移出“即将回收”的集合，否则基本上就真的要被回收了。

finalize方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，已不被推荐使用。因此忘掉即可。


## 回收方法区
方法区的回收对象只有有2种：**废弃的常量**（如字符串字面量）和**不再使用的类型**。

类型卸载需同时满足以下三个条件：
* 该类所有的对象实例都已被回收，即Java堆中不存在该类及其派生子类的实例
* 加载该类的类加载器已被回收，该条件只有在精心设计的场景下，比如OSGi、JSP的重加载等，才可能达成
* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

Java虚拟机被允许对满足以上三个条件的类型进行回收，但只是“被允许”，而不是一定会被回收。

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。


## 垃圾收集算法

### 标记-清除


### 标记-复制


### 标记-整理


### 分代收集


















