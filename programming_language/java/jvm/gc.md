# Java GC（Garbage Collection）

## GC需要解决的三件事
* 哪些内存需要回收？
* 什么时候回收？
* 如何回收？

## 关注的内存区域
由于程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而灭，栈帧随方法进入和退出而入栈和出栈，这部分内存的分配和回收时机都是确定的，不属于GC关注的内存区域。

而**Java堆和元空间**则具有不确定性，比如同一个接口的实现类所需要的内存可能是不一样的，程序的不同分支所需的内存也可能会不一样，只有在运行期，程序才能知道会创建哪些对象，会创建多少个对象，这部分内存的分配和回收都是动态的，因此是GC关注的内存区域。

### OOM发生的几个原因：
* 内存的容量太小了，需要扩容，或者需要调整堆的空间。
* 错误的引用方式，发生了内存泄漏。没有及时的切断与 GC Roots 的关系。比如线程池里的线程，在复用的情况下忘记清理 ThreadLocal 的内容。
* 接口没有进行范围校验，外部传参超出范围。比如数据库查询时的每页条数等。
* 对堆外内存无限制的使用。这种情况一旦发生更加严重，会造成操作系统内存耗尽。

典型的内存泄漏场景，原因在于对象没有及时的释放自己的引用。比如一个局部变量，被外部的静态集合引用。

## 对象已死？

1. 引用计数法  
在对象中增加一个引用计数器，当有引用指向它时+1，当指向它的引用失效时-1。当其引用计数为0时，则成为垃圾。但采用该算法有一些例外情况需额外处理，如循环引用等。

2. 可达性分析法  
通过一序列称为“GC Roots”的根对象为起点，根据引用关系向下遍历，搜索过程走过的路径称为“引用链”，当遍历结束时，不在引用链上的对象即为垃圾对象。

固定可作为**GC Roots**的对象包括以下几种：
* 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如线程中被调用的方法栈帧中的参数、局部变量、临时变量等（运行上下文）
* 本地方法栈中JNI引用的对象（JNI句柄，包括JNI Local Handles 和 JNI Global Handles）（运行上下文）
* 所有被同步锁（synchronized）持有的对象（运行上下文）
* 方法区（元空间）中类静态属性引用的对象，譬如Java类的引用类型静态变量（全局）
* 方法区（元空间）中常量引用的对象，譬如字符串常量池中的引用（全局）
* JVM内部的引用，譬如基本数据类型对应的Class对象、一些常驻的异常对象（NullPointException、OutOfMemoryError）等、类加载器（全局）
* 反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等（全局）

除这些固定的GC Roots外，根据用户选择的垃圾收集器以及当前收集的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整的GC Roots集合。比如分代收集和局部回收（Partail GC），当只回收Java堆某一局部内存时（比如新生代），需考虑可能存在其他区域对象对该区域的引用（比如老年代指向新生代的引用），因此需将其关联的内存区域对象也加入到GC Roots中，才能保证可达性分析的正确性。

    注：
    1）GC Roots是引用，而不是对象；
    2）GC过程是找出所有存活对象，将其他空间设为无用；而不是找出所有死亡对象并回收它们的空间。所以说即使堆空间很大，基于Tracing的GC方式，回收速度是很快的。

## 四种引用
* 强引用（Strongly Reference）：常见的引用赋值，存在强引用的对象永远不会被回收。
* 软引用（SoftReference）：只有软引用的对象在内存足够时不被回收，但如果内存不足，则在溢出之前会被回收，若还不足才报溢出异常。  
* 弱引用（WeakReference）：只有弱引用的对象在下一轮垃圾收集时被回收。
* 虚引用（PhanthonReference）：也被称为“幽灵引用”或“幻象引用”，不影响对象的生存时间，也不能通过它获得对象实例。设置虚引用的唯一目的是在对象被回收时收到一个通知。

      // 软引用
      Object object = new Object();
      SoftReference<Object> softRef = new SoftReference(object);
      
      // 弱引用
      WeakReference<Object> softRef = new WeakReference(object);
      
      ReferenceQueue queue = new ReferenceQueue();
      // 虚引用，必须与一个引用队列关联
      PhantomReference pr = new PhantomReference(object, queue);
    

## 应该忘掉的对象逃生之术- finalize()方法
一个对象被宣告死亡，至少要经历两次标记过程。当对象不在GC Roots引用链上时被第一次标记，然后会进行一次筛选，筛选的条件是该对象是否需要执行finalize方法。如果对象没有覆盖finalize方法或者finalize方法已被调用过，则认为该对象不需要执行finalize方法。

如果判定要执行finalize方法的话，则该对象会被放入到一个F-Queue队列中，由JVM创建的一个低调度优先级的Finalizer线程来执行该队列中的对象的finalize方法（只触发不保证执行结束）。这是对象逃脱死亡命运的最后一次机会。稍后收集器会对F-Queue队列中的对象进行第二次小规模标记，成功逃脱的对象则被移出“即将回收”的集合，否则基本上就真的要被回收了。

finalize方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，已不被推荐使用。因此忘掉即可。


## 回收方法区
方法区的回收对象只有有2种：**废弃的常量**（如字符串字面量）和**不再使用的类型**。

类型卸载需同时满足以下三个条件：
* 该类所有的对象实例都已被回收，即Java堆中不存在该类及其派生子类的实例
* 加载该类的类加载器已被回收，该条件只有在精心设计的场景下，比如OSGi、JSP的重加载等，才可能达成
* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

Java虚拟机被允许对满足以上三个条件的类型进行回收，但只是“被允许”，而不是一定会被回收。

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。


## 垃圾收集算法

### 始于分代收集理论
分代收集理论实质上是大多数程序运行实际情况的经验法则，它建立在以下两条假说之上：

* 弱分代假说（Weak Generational Hypothesis）：**大多数对象都是朝生夕灭的**。
* 强分代假说（Strong Generational Hypothesis）：**熬过越多次垃圾收集过程的对象就越难以消亡**。

因此，将内存区域按对象年龄划分到不同的区域，比如新生代、老年代等，根据它们存储的对象存亡特征采用不同的垃圾回收策略，从而同时兼顾垃圾收集的时间开销和内存的空间有效利用。基于此发展起来的算法包括：标记-清除、标记-复制、标记-整理。

但需注意的是，在进行局部内存回收时，比如回收新生代，由于可能存在老年代跨代引用新生代对象，就必须也遍历老年代对象才能保证可达性分析算法的正确性，但这样显然效率不高，分代本身就为了减少对象全局扫描。因此还需要对分代收集理论添加第三条经验法则：

* 跨代引用假说（InterGenerational Reference Hypothesis）：**跨代引用相对同代引用来说只占极少数**。

这条假说可以说是前两条假说的隐含推论。因为互相引用的对象，应该是倾向于同时生存或同时消亡的。例如：一个新生代对象存在跨代引用，由于老年代对象难消亡，该引用会使得新生代对象在垃圾收集时也得以回收，进而逐步晋升到老年代中。

基于这条假说，我们就不应该为少量的跨代引用扫描整个老年代，也不必浪费空间为每个对象都记录其是否存在跨代引用。而是可以采用一种被称为“记忆集（Remembered Set）”的全局的数据结构，将老年代划分为若干小块，标识哪块内存存在跨代引用。因此在Minor GC时，只需要将包含了跨代引用的那些块的内存里的对象加入GC Roots即可。

    对象进入老年代的几个途径：
    1）提升（Promotion）
       根据GC age判断，通过‐XX:+MaxTenuringThreshold 进行配置（最大值为15，用4bit保存）；
    2）分配担保（Handle Promotion）
       回收新生代时将存活对象保存到某个Survivor（占比10%）中，如果存活对象所需空间大于Survivor空间，则通过老年代的分配担保机制直接进入到老年代。
    3）大对象直接在老年代分配
       超过某个大小的对象直接在老年代分配，通过参数 -XX:PretenureSizeThreshold设置。默认为0，即全部对象优先在Eden中分配。
    4）动态对象年龄判定
       有的垃圾回收算法，并不要求 age 必须达到 15 才能晋升到老年代，它会使用一些动态的计算方法。比如，如果幸存区中相同年龄对象大小的和，大于幸存区的一半，
       大于或等于 age 的对象将会直接进入老年代。

    对象分配逻辑：https://s0.lgstatic.com/i/image3/M01/62/73/Cgq2xl4lQuiAM7ZPAABnAlb8gZ8269.jpg

### 标记-清除算法
* 优点：简单
* 缺点：1）效率不稳定，收集效率随待回收对象的增长而降低；2）内存碎片。

### 标记-复制算法
* 半区复制：将内存划分为相等的两份，一份用于分配，一份用于在回收时保存存活对象。
* 优点：当只有极少数对象存活时，效率较高，且在内存分配时，由于不需要考虑内存碎片，可简单移动堆顶指针即可，内存分配效率高。适合新生代这种大多数对象朝生夕灭的场景。
* 缺点：浪费一半空间。
* 半区复制优化：针对绝大多数朝生夕灭的新生代区域，将其划分为Eden区和2个Survivor区，比例为8:1。这样可用内存占比为90%。但由于不能保证每次存活对象占比都在10%以内，因此需要老年代提供**“分配担保（Handle Promotion）”**，在Survivor不足以保存存活对象时，将这些对象通过分配担保机制直接进入老年代。

### 标记-整理算法
当大多数对象存活时，复制算法由于存在大量内存复制，效率降低，同时由于需要分配担保机制，因此标记-复制算法不适用于老年代。而针对老年代的算法是：标记-整理。

* 原理：将存活对象往某一端**移动**，然后清除掉边界以外的内存。
* 优点：不存在内存碎片，内存分配效率高（频繁动作），应用程序的吞吐量较高。
* 缺点：对于老年代这种每次回收都有大量对象存活区域，移动存活对象并且更新所有引用这些对象的地方是一个非常负重的操作，而且移动对象往往需要暂停用户线程（也有例外，比如ZGC和Shenandoah采用读屏障做到整理过程与用户线程的并发执行），垃圾收集停顿时间长。

从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点。


## Hotspot算法细节

### 根结点枚举
固定可作为GC Roots的节点主要在**全局性的引用**（如常量或类静态属性）与**执行上下文**（如栈帧中的本地变量表）中，尽管目标明确，但要做到高效查找并非易事。

迄今为止，所有收集器在根节点枚举过程都需要“Stop The World”，保证该过程始终一个**一致性的快照**中进行，这样才能保证分析结果的准确。

目前主流Java虚拟机采用的是**准确式垃圾收集**（即虚拟机可以知道所有的内存位置存放的是数值还是引用），因此，虚拟机有办法直接得到哪些地方存放着对象引用。

#### OopMap
在HotSpot解决方案中，使用一组OopMap（OOP：Ordinary Object Pointer）的数据结构来达到目的。






